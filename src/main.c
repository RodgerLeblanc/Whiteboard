/*
 
This watchface loads black digits on a white screen and inverts it if the bluetooth connection is lost.
I added "Quick Tap Plus" for battery level lookup. Check it here : https://github.com/grep-awesome/QuickTapPlus

 */

#include "pebble.h"
#include "QTPlus.h"
	
static Window *window;

TextLayer *connection_layer;
InverterLayer *inv_layer;

//
// There's only enough memory to load about 6 of 10 required images
// so we have to swap them in & out...
//
// We have one "slot" per digit location on screen.
//
// Because layers can only have one parent we load a digit for each
// slot--even if the digit image is already in another slot.
//
// Slot on-screen layout:
//     0 1
//     2 3
//
#define TOTAL_IMAGE_SLOTS 4

#define NUMBER_OF_IMAGES 10

// These images are 72 x 84 pixels (i.e. a quarter of the display),
// black and white with the digit character centered in the image.
// (As generated by the `fonttools/font2png.py` script.)
const int IMAGE_RESOURCE_IDS[NUMBER_OF_IMAGES] = {
    RESOURCE_ID_IMAGE_NUM_0, RESOURCE_ID_IMAGE_NUM_1, RESOURCE_ID_IMAGE_NUM_2,
    RESOURCE_ID_IMAGE_NUM_3, RESOURCE_ID_IMAGE_NUM_4, RESOURCE_ID_IMAGE_NUM_5,
    RESOURCE_ID_IMAGE_NUM_6, RESOURCE_ID_IMAGE_NUM_7, RESOURCE_ID_IMAGE_NUM_8,
    RESOURCE_ID_IMAGE_NUM_9
};

// Set to 61 so it refresh on window load
int min = 61;

bool was_BTconnected_last_time;

/*

 Each duration corresponds to alternating on/off periods, starting on.

 An even number of segments means the last period will be the
 minimum time between the end of this pattern and the start of the
 next queued pattern (if any). If odd, a spacing time will be used in
 its place.

 */

static const VibePattern custom_pattern_20 = {
  .durations = (uint32_t []) {300, 300, 300, 300, 300, 300, 300, 300},
  .num_segments = 8
};  // 4 medium vibes

static const VibePattern custom_pattern_10 = {
  .durations = (uint32_t []) {100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100},
  .num_segments = 12
};  // 6 short vibes


static GBitmap *images[TOTAL_IMAGE_SLOTS];
static BitmapLayer *image_layers[TOTAL_IMAGE_SLOTS];

#define EMPTY_SLOT -1

// The state is either "empty" or the digit of the image currently in
// the slot--which was going to be used to assist with de-duplication
// but we're not doing that due to the one parent-per-layer
// restriction mentioned above.
static int image_slot_state[TOTAL_IMAGE_SLOTS] = {EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT, EMPTY_SLOT};

static void load_digit_image_into_slot(int slot_number, int digit_value) {

	/*
     
     Loads the digit image from the application's resources and
     displays it on-screen in the correct location.
     
     Each slot is a quarter of the screen.
     
     */
    
    // TODO: Signal these error(s)?
    
    if ((slot_number < 0) || (slot_number >= TOTAL_IMAGE_SLOTS)) {
        return;
    }
    
    if ((digit_value < 0) || (digit_value > 9)) {
        return;
    }
    
    if (image_slot_state[slot_number] != EMPTY_SLOT) {
        return;
    }
    
    image_slot_state[slot_number] = digit_value;
	images[slot_number] = gbitmap_create_with_resource(IMAGE_RESOURCE_IDS[digit_value]);
    GRect frame = (GRect) {
        .origin = { (slot_number % 2) * 72, (slot_number / 2) * 84 },
        .size = images[slot_number]->bounds.size
    };
    BitmapLayer *bitmap_layer = bitmap_layer_create(frame);
    image_layers[slot_number] = bitmap_layer;
    bitmap_layer_set_bitmap(bitmap_layer, images[slot_number]);
	Layer *window_layer = window_get_root_layer(window);
    layer_add_child(window_layer, bitmap_layer_get_layer(bitmap_layer));
}

static void unload_digit_image_from_slot(int slot_number) {
    /*
     
     Removes the digit from the display and unloads the image resource
     to free up RAM.
     
     Can handle being called on an already empty slot.
     
     */
    
    if (image_slot_state[slot_number] != EMPTY_SLOT) {
        layer_remove_from_parent(bitmap_layer_get_layer(image_layers[slot_number]));
        bitmap_layer_destroy(image_layers[slot_number]);
        gbitmap_destroy(images[slot_number]);
        image_slot_state[slot_number] = EMPTY_SLOT;
    }
    
}

static void display_value(unsigned short value, unsigned short row_number, bool show_first_leading_zero) {
    /*
     
     Displays a numeric value between 0 and 99 on screen.
     
     Rows are ordered on screen as:
     
     Row 0
     Row 1
     
     Includes optional blanking of first leading zero,
     i.e. displays ' 0' rather than '00'.
     
     */
	
	value = value % 100; // Maximum of two digits per row.
    
    // Column order is: | Column 0 | Column 1 |
    // (We process the columns in reverse order because that makes
    // extracting the digits from the value easier.)
    for (int column_number = 1; column_number >= 0; column_number--) {
        int slot_number = (row_number * 2) + column_number;
        unload_digit_image_from_slot(slot_number);
        if (!((value == 0) && (column_number == 0) && !show_first_leading_zero)) {
			load_digit_image_into_slot(slot_number, value % 10);
        }
        value = value / 10;
    }
}

static unsigned short get_display_hour(unsigned short hour) {
    
    if (clock_is_24h_style()) {
        return hour;
    }
    
    unsigned short display_hour = hour % 12;
    
    // Converts "0" to "12"
    return display_hour ? display_hour : 12;
    
}

static void display_time(struct tm *tick_time) {
    
    // TODO: Use `units_changed` and more intelligence to reduce
    //       redundant digit unload/load?
	
	// This is to make sure the screen is not refreshed every second
	if (tick_time->tm_min != min)  {
		if (was_BTconnected_last_time)  {
			window_set_background_color(window, GColorWhite);
			display_value(get_display_hour(tick_time->tm_hour), 0, false);
			display_value(tick_time->tm_min, 1, true);
			min = tick_time->tm_min;
		}
		else  {
			// Destroy previous inverter layer to make sure there's no inverted spot if first digit is missing (ie: " 0:12")
			inverter_layer_destroy(inv_layer);
			window_set_background_color(window, GColorWhite);
			display_value(get_display_hour(tick_time->tm_hour), 0, false);
			display_value(tick_time->tm_min, 1, true);
			min = tick_time->tm_min;
			//Inverter layer
			inv_layer = inverter_layer_create(GRect(0, 0, 144, 168));
			layer_add_child(window_get_root_layer(window), (Layer*) inv_layer);	
		}		
	}
}

static void handle_minute_tick(struct tm *tick_time, TimeUnits units_changed) {
    display_time(tick_time);
}

void bluetooth_handler(bool connected) {
	//	This handler is called when BT connection state changes

	// Destroy inverter layer if BT changed from disconnected to connected
	if ((connected) && (!(was_BTconnected_last_time)))  {
		inverter_layer_destroy(inv_layer);
	}
	time_t now = time(NULL);
    struct tm *tick_time = localtime(&now);
	window_set_background_color(window, GColorWhite);
	display_value(get_display_hour(tick_time->tm_hour), 0, false);
	display_value(tick_time->tm_min, 1, true);
	//Inverter layer in case of disconnect
	if (!(connected)) {
		inv_layer = inverter_layer_create(GRect(0, 0, 144, 168));
		layer_add_child(window_get_root_layer(window), (Layer*) inv_layer);	
		vibes_double_pulse();
	}
	was_BTconnected_last_time = connected;
}

void make_vibes_20()  {
	vibes_enqueue_custom_pattern(custom_pattern_20);
}

void make_vibes_10()  {
	vibes_enqueue_custom_pattern(custom_pattern_10);
}

void battery_handler() {
	BatteryChargeState batt;
	batt = battery_state_service_peek();
	if ((batt.charge_percent <= 20) && (batt.charge_percent > 10))  {
		make_vibes_20();
	}
	if (batt.charge_percent <= 10)  {
		make_vibes_10();
	}
}

static void init() {
    window = window_create();
    window_stack_push(window, true);
	was_BTconnected_last_time = bluetooth_connection_service_peek();
	// Avoids a blank screen on watch start.
	bluetooth_handler(was_BTconnected_last_time);
	battery_handler();
	tick_timer_service_subscribe(MINUTE_UNIT, handle_minute_tick);
	bluetooth_connection_service_subscribe( bluetooth_handler );
	battery_state_service_subscribe( battery_handler );	
}

static void deinit() {
    for (int i = 0; i < TOTAL_IMAGE_SLOTS; i++) {
        unload_digit_image_from_slot(i);
    }    
    window_destroy(window);
	// Destroy inverter if last screen was inverted
	if (!(was_BTconnected_last_time))  {
		inverter_layer_destroy(inv_layer);
	}
	qtp_app_deinit();
	tick_timer_service_unsubscribe();
	bluetooth_connection_service_unsubscribe();
	battery_state_service_unsubscribe();	
}

int main(void) {
	qtp_conf = QTP_K_SHOW_TIME | QTP_K_AUTOHIDE | QTP_K_INVERT;
	init();
	qtp_setup();
    app_event_loop();
    deinit();
}
